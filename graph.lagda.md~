# Formalization of [Algebraic Graphs with Class](https://dl.acm.org/doi/10.1145/3122955.3122956)

```
{-# OPTIONS --rewriting #-}

module graph where

open import Agda.Builtin.Equality
open import Agda.Builtin.Equality.Rewrite

open import Function

open import Data.List
open import Data.List.Properties using (++-identityʳ)
open import Data.Bool
open import Data.Empty using (⊥; ⊥-elim)

open import Relation.Binary.PropositionalEquality as Eq hiding ([_])
open Eq using (_≡_; refl; sym; trans; cong; cong₂; _≢_)
-- open Eq.≡-Reasoning using (begin_; _≡⟨⟩_; _∎)

open import Relation.Nullary using (Dec; yes; no; ¬_)
open import Relation.Nullary.Negation using (contradiction)
```

```
data Graph (A : Set) : Set where
  ε : Graph A
  Vertex : A → Graph A
  _+_ : Graph A → Graph A → Graph A
  _⇀_ : Graph A → Graph A → Graph A
```

- `Empty` is the empty graph
- `Vertex` is the singleton graph
- `Overlay` takes the union of the vertices and edges of 2 graphs
- `Connect` overlay + create edges between all the vertices in the 2 graphs

```
data _∈ᵥ_ { A : Set } : A → Graph A → Set where
  x∈Vx : ∀ { x : A } → x ∈ᵥ Vertex x
  +ₗ : ∀ { x : A } { G H : Graph A } → x ∈ᵥ G → x ∈ᵥ (G + H)
  +ᵣ : ∀ { x : A } { G H : Graph A } → x ∈ᵥ H → x ∈ᵥ (G + H)
  ⇀ₗ : ∀ { x : A } { G H : Graph A } → x ∈ᵥ G → x ∈ᵥ (G ⇀ H)
  ⇀ᵣ : ∀ { x : A } { G H : Graph A } → x ∈ᵥ H → x ∈ᵥ (G ⇀ H)

data ⟦_,_⟧∈ₑ_ { A : Set } : A → A → Graph A → Set where
  +ₗ : ∀ { x y : A } { G H : Graph A } → ⟦ x , y ⟧∈ₑ G → ⟦ x , y ⟧∈ₑ (G + H)
  +ᵣ : ∀ { x y : A } { G H : Graph A } → ⟦ x , y ⟧∈ₑ H → ⟦ x , y ⟧∈ₑ (G + H)
  ⇀ₗ : ∀ { x y : A } { G H : Graph A } → ⟦ x , y ⟧∈ₑ G → ⟦ x , y ⟧∈ₑ (G ⇀ H)
  ⇀ᵣ : ∀ { x y : A } { G H : Graph A } → ⟦ x , y ⟧∈ₑ H → ⟦ x , y ⟧∈ₑ (G ⇀ H)
  ⇀ₗᵣ : ∀ { x y : A } { G H : Graph A } → x ∈ᵥ G → y ∈ᵥ H → ⟦ x , y ⟧∈ₑ (G ⇀ H)

record _≈_ { A : Set } ( G H : Graph A ) : Set where
  field
    vₗ : ∀ { x : A } → x ∈ᵥ G → x ∈ᵥ H
    vᵣ : ∀ { x : A } → x ∈ᵥ H → x ∈ᵥ G
    eₗ : ∀ { x y : A } → ⟦ x , y ⟧∈ₑ G → ⟦ x , y ⟧∈ₑ H
    eᵣ : ∀ { x y : A } → ⟦ x , y ⟧∈ₑ H → ⟦ x , y ⟧∈ₑ G

record _≲_ { A : Set } ( G H : Graph A ) : Set where
  field
    vₗ : ∀ { x : A } → x ∈ᵥ G → x ∈ᵥ H
    eₗ : ∀ { x y : A } → ⟦ x , y ⟧∈ₑ G → ⟦ x , y ⟧∈ₑ H
```

Two graphs are equal if:

- Vertex x in G iff x in H
- Edge (x, y) in G iff (x, y) in H

A graph is a subgraph if:

- Vertex x in H if x in G
- Edge (x, y) in H if (x, y) in G

```
≈→≲ : ∀ { A : Set } { G H : Graph A } → G ≈ H → G ≲ H
≈→≲ x = record { vₗ = _≈_.vₗ x ; eₗ = _≈_.eₗ x }

≈-comm : ∀ { A : Set } { G H : Graph A } → G ≈ H → H ≈ G
≈-comm x = record { vₗ = _≈_.vᵣ x ; vᵣ = _≈_.vₗ x ; eₗ = _≈_.eᵣ x ; eᵣ = _≈_.eₗ x }

≈-trans : ∀ { A : Set } { G H I : Graph A } → G ≈ H → H ≈ I → G ≈ I
≈-trans G≈H H≈I = record
                    { vₗ = λ z → _≈_.vₗ H≈I (_≈_.vₗ G≈H z)
                    ; vᵣ = λ z → _≈_.vᵣ G≈H (_≈_.vᵣ H≈I z)
                    ; eₗ = λ z → _≈_.eₗ H≈I (_≈_.eₗ G≈H z)
                    ; eᵣ = λ z → _≈_.eᵣ G≈H (_≈_.eᵣ H≈I z)
                    }

≈-refl : ∀ { A : Set } { G : Graph A } → G ≈ G
≈-refl = record
           { vₗ = λ z → z
           ; vᵣ = λ z → z
           ; eₗ = λ z → z
           ; eᵣ = λ z → z
           }
```

```
module ≈-Reasoning { A : Set } where

  infix 1 begin_
  infixr 2 _≈⟨⟩_ _≈⟨_⟩_
  infix 3 _∎

  begin_ : ∀ { G H : Graph A } → G ≈ H → G ≈ H
  begin G≈H = G≈H

  _≈⟨⟩_ : ∀ (G : Graph A) { H : Graph A } → G ≈ H → G ≈ H
  G ≈⟨⟩ G≈H = G≈H

  _≈⟨_⟩_ : ∀ (G : Graph A) { H I : Graph A } → G ≈ H → H ≈ I → G ≈ I
  G ≈⟨ G≈H ⟩ H≈I = ≈-trans G≈H H≈I

  _∎ : ∀ (G : Graph A) → G ≈ G
  G ∎ = ≈-refl

open ≈-Reasoning
```

```
+-comm : ∀ { A : Set } { G H : Graph A } → (G + H) ≈ (H + G)
+-comm = record
  { vₗ = λ { (+ₗ x) → +ᵣ x ; (+ᵣ x) → +ₗ x }
  ; vᵣ = λ { (+ₗ x) → +ᵣ x ; (+ᵣ x) → +ₗ x }
  ; eₗ = λ { (+ₗ x) → +ᵣ x ; (+ᵣ x) → +ₗ x }
  ; eᵣ = λ { (+ₗ x) → +ᵣ x ; (+ᵣ x) → +ₗ x }
  }

+-assoc : ∀ { A : Set } { G H I : Graph A } → (G + (H + I)) ≈ ((G + H) + I)
+-assoc = record
  { vₗ = λ { (+ₗ x) → +ₗ (+ₗ x) ; (+ᵣ (+ₗ x)) → +ₗ (+ᵣ x) ; (+ᵣ (+ᵣ x)) → +ᵣ x }
  ; vᵣ = λ { (+ₗ (+ₗ x)) → +ₗ x ; (+ₗ (+ᵣ x)) → +ᵣ (+ₗ x) ; (+ᵣ x) → +ᵣ (+ᵣ x) }
  ; eₗ = λ { (+ₗ x) → +ₗ (+ₗ x) ; (+ᵣ (+ₗ x)) → +ₗ (+ᵣ x) ; (+ᵣ (+ᵣ x)) → +ᵣ x }
  ; eᵣ = λ { (+ₗ (+ₗ x)) → +ₗ x ; (+ₗ (+ᵣ x)) → +ᵣ (+ₗ x) ; (+ᵣ x) → +ᵣ (+ᵣ x) }
  }
  
+-identˡ : ∀ { A : Set } { G : Graph A } → (G + ε) ≈ G
+-identˡ = record
  { vₗ = λ { (+ₗ x) → x }
  ; vᵣ = λ x → +ₗ x
  ; eₗ = λ { (+ₗ x) → x }
  ; eᵣ = +ₗ 
  }

+-identʳ : ∀ { A : Set } { G : Graph A } → (ε + G) ≈ G
+-identʳ = record
  { vₗ = λ { (+ᵣ x) → x }
  ; vᵣ = +ᵣ
  ; eₗ = λ { (+ᵣ x) → x }
  ; eᵣ = +ᵣ
  }

∈ᵥ-+-subst : ∀ { A : Set } { G H I : Graph A } { x : A } → G ≈ H → x ∈ᵥ (G + I) → x ∈ᵥ (H + I)
∈ᵥ-+-subst H≈I (+ₗ x) = +ₗ (_≈_.vₗ H≈I x)
∈ᵥ-+-subst H≈I (+ᵣ x) = +ᵣ x

∈ₑ-+-subst : ∀ { A : Set } { G H I : Graph A } { x y : A } → G ≈ H → ⟦ x , y ⟧∈ₑ (G + I) → ⟦ x , y ⟧∈ₑ (H + I)
∈ₑ-+-subst G≈H (+ₗ x) = +ₗ (_≈_.eₗ G≈H x)
∈ₑ-+-subst G≈H (+ᵣ x) = +ᵣ x

+-subst : ∀ { A : Set } { G H I J : Graph A } → G ≈ H → (G + I) ≈ J → (H + I) ≈ J
+-subst G≈H GI≈J = record
                     { vₗ = λ { (+ₗ x) → _≈_.vₗ GI≈J (+ₗ (_≈_.vᵣ G≈H x)) ; (+ᵣ x) → _≈_.vₗ GI≈J (+ᵣ x) }
                     ; vᵣ = λ x → ∈ᵥ-+-subst G≈H (_≈_.vᵣ GI≈J x)
                     ; eₗ = λ { (+ₗ x) → _≈_.eₗ GI≈J (+ₗ (_≈_.eᵣ G≈H x)) ; (+ᵣ x) → _≈_.eₗ GI≈J (+ᵣ x) }
                     ; eᵣ = λ x → ∈ₑ-+-subst G≈H (_≈_.eᵣ GI≈J x)
                     }

∈ᵥ-⇀-subst : ∀ { A : Set } { G H I : Graph A } { x : A } → G ≈ H → x ∈ᵥ (G ⇀ I) → x ∈ᵥ (H ⇀ I)
∈ᵥ-⇀-subst G≈H (⇀ₗ x) = ⇀ₗ (_≈_.vₗ G≈H x)
∈ᵥ-⇀-subst G≈H (⇀ᵣ x) = ⇀ᵣ x

∈ₑ-⇀-subst : ∀ { A : Set } { G H I : Graph A } { x y : A } → G ≈ H → ⟦ x , y ⟧∈ₑ (G ⇀ I) → ⟦ x , y ⟧∈ₑ (H ⇀ I)
∈ₑ-⇀-subst G≈H (⇀ₗ x) = ⇀ₗ (_≈_.eₗ G≈H x)
∈ₑ-⇀-subst G≈H (⇀ᵣ x) = ⇀ᵣ x
∈ₑ-⇀-subst G≈H (⇀ₗᵣ x x₁) = ⇀ₗᵣ (_≈_.vₗ G≈H x) x₁

⇀-subst : ∀ { A : Set } { G H I J : Graph A } → G ≈ H → (G ⇀ I) ≈ J → (H ⇀ I) ≈ J
⇀-subst G≈H GI≈J = record
                     { vₗ = λ { (⇀ₗ x) → _≈_.vₗ GI≈J (⇀ₗ (_≈_.vᵣ G≈H x)) ; (⇀ᵣ x) → _≈_.vₗ GI≈J (⇀ᵣ x) }
                     ; vᵣ = λ x → ∈ᵥ-⇀-subst G≈H (_≈_.vᵣ GI≈J x)
                     ; eₗ = λ { (⇀ₗ x) → _≈_.eₗ GI≈J (⇀ₗ (_≈_.eᵣ G≈H x)) ; (⇀ᵣ x) → _≈_.eₗ GI≈J (⇀ᵣ x) ; (⇀ₗᵣ x x₁) → _≈_.eₗ GI≈J (⇀ₗᵣ (_≈_.vᵣ G≈H x) x₁) }
                     ; eᵣ = λ x → ∈ₑ-⇀-subst G≈H (_≈_.eᵣ GI≈J x)
                     }
```

+ is commutative, associative and ε is an identity element.

```
⇀-assoc : ∀ { A : Set } { G H I : Graph A } → (G ⇀ (H ⇀ I)) ≈ ((G ⇀ H) ⇀ I)
⇀-assoc = record
  { vₗ = λ { (⇀ₗ x) → ⇀ₗ (⇀ₗ x) ; (⇀ᵣ (⇀ₗ x)) → ⇀ₗ (⇀ᵣ x) ; (⇀ᵣ (⇀ᵣ x)) → ⇀ᵣ x }
  ; vᵣ = λ { (⇀ₗ (⇀ₗ x)) → ⇀ₗ x ; (⇀ₗ (⇀ᵣ x)) → ⇀ᵣ (⇀ₗ x) ; (⇀ᵣ x) → ⇀ᵣ (⇀ᵣ x) }
  ; eₗ = λ { (⇀ₗ x) → ⇀ₗ (⇀ₗ x) ; (⇀ᵣ (⇀ₗ x)) → ⇀ₗ (⇀ᵣ x) ; (⇀ᵣ (⇀ᵣ x)) → ⇀ᵣ x ; (⇀ᵣ (⇀ₗᵣ x x₁)) → ⇀ₗᵣ (⇀ᵣ x) x₁ ; (⇀ₗᵣ x (⇀ₗ x₁)) → ⇀ₗ (⇀ₗᵣ x x₁) ; (⇀ₗᵣ x (⇀ᵣ x₁)) → ⇀ₗᵣ (⇀ₗ x) x₁ }
  ; eᵣ = λ { (⇀ₗ (⇀ₗ x)) → ⇀ₗ x ; (⇀ₗ (⇀ᵣ x)) → ⇀ᵣ (⇀ₗ x) ; (⇀ₗ (⇀ₗᵣ x x₁)) → ⇀ₗᵣ x (⇀ₗ x₁) ; (⇀ᵣ x) → ⇀ᵣ (⇀ᵣ x) ; (⇀ₗᵣ (⇀ₗ x) x₁) → ⇀ₗᵣ x (⇀ᵣ x₁) ; (⇀ₗᵣ (⇀ᵣ x) x₁) → ⇀ᵣ (⇀ₗᵣ x x₁) }
  }
 
⇀-identˡ : ∀ { A : Set } { G : Graph A } → (G ⇀ ε) ≈ G
⇀-identˡ = record
  { vₗ = λ { (⇀ₗ x) → x }
  ; vᵣ = ⇀ₗ
  ; eₗ = λ { (⇀ₗ x) → x }
  ; eᵣ = ⇀ₗ
  }

⇀-identʳ : ∀ { A : Set } { G : Graph A } → (ε ⇀ G) ≈ G
⇀-identʳ = record
  { vₗ = λ { (⇀ᵣ x) → x }
  ; vᵣ = ⇀ᵣ
  ; eₗ = λ { (⇀ᵣ x) → x }
  ; eᵣ = ⇀ᵣ
  }
```

⇀ is associative and ε is an identity element

```
ε-noedge : ∀ { A : Set } { x y : A } → ¬ (⟦ x , y ⟧∈ₑ ε)
ε-noedge = λ ()
```

```
edge : {A : Set} → A → A → Graph A
edge x y = (Vertex x) ⇀ (Vertex y)

vertices : {A : Set} → List A → Graph A
vertices = (foldr _+_ ε) ∘ (map Vertex)

clique : {A : Set} → List A → Graph A
clique = (foldr _⇀_ ε) ∘ (map Vertex)
```

```
_ : { A : Set } → ∀ { x : A } → vertices [ x ] ≈ Vertex x
_ = record
  { vₗ = λ { (+ₗ x) → x }
  ; vᵣ = +ₗ
  ; eₗ = λ { (+ₗ x) → x ; (+ᵣ x) → contradiction x λ () }
  ; eᵣ = λ ()
  }

_ : { A : Set } → ∀ { x y : A } → (edge x y) ≈ (clique (x ∷ (y ∷ [])))
_ = record
  { vₗ = λ { (⇀ₗ x) → ⇀ₗ x ; (⇀ᵣ x) → ⇀ᵣ (⇀ₗ x) }
  ; vᵣ = λ { (⇀ₗ x) → ⇀ₗ x ; (⇀ᵣ (⇀ₗ x)) → ⇀ᵣ x }
  ; eₗ = λ { (⇀ₗᵣ x x₁) → ⇀ₗᵣ x (⇀ₗ x₁) }
  ; eᵣ = λ
    { (⇀ᵣ (⇀ₗ x)) → ⇀ᵣ x
    ; (⇀ᵣ (⇀ᵣ x)) → contradiction x λ ()
    ; (⇀ᵣ (⇀ₗᵣ x x₁)) → contradiction x₁ λ ()
    ; (⇀ₗᵣ x (⇀ₗ x₁)) → ⇀ₗᵣ x x₁
    }
  }

vertices-∈ᵥ-∷ : { A : Set } → ∀ { x : A } ( y : A ) { xs : List A } → x ∈ᵥ vertices xs → x ∈ᵥ vertices (y ∷ xs)
vertices-∈ᵥ-∷ y x∈xs = +ᵣ x∈xs

clique≲clique∷ : { A : Set } → ∀ ( xs : List A ) ( x : A ) → (clique xs) ≲ (clique (x ∷ xs))
clique≲clique∷ xs x = record
  { vₗ = ⇀ᵣ
  ; eₗ = ⇀ᵣ
  }

vertices≲clique : { A : Set } → ∀ ( xs : List A ) → (vertices xs) ≲ (clique xs)
vertices≲clique [] = record { vₗ = λ z → z ; eₗ = λ z → z }
vertices≲clique (x ∷ xs) = record
  { vₗ = λ
    { (+ₗ x₁) → ⇀ₗ x₁
    ; (+ᵣ x₁) → _≲_.vₗ (clique≲clique∷ xs x) (_≲_.vₗ (vertices≲clique xs) x₁)
    }
  ; eₗ = λ
    { (+ᵣ x₁) → _≲_.eₗ (clique≲clique∷ xs x) (_≲_.eₗ (vertices≲clique xs) x₁) }
    }

clique[]≈ε : { A : Set } → (clique []) ≈ ε { A }
clique[]≈ε = record
  { vₗ = λ z → z
  ; vᵣ = λ z → z
  ; eₗ = λ z → z
  ; eᵣ = λ z → z
  }

clique∈ᵥclique∷ : { A : Set } → ∀ ( xs : List A ) ( x y : A ) → y ∈ᵥ (clique xs) → y ∈ᵥ (clique (x ∷ xs))
clique∈ᵥclique∷ xs x y y∈xs = ⇀ᵣ y∈xs

clique∈ᵥclique++ʳ : { A : Set } → ∀ ( xs ys : List A ) ( x : A ) → x ∈ᵥ (clique ys) → x ∈ᵥ (clique (xs ++ ys))
clique∈ᵥclique++ʳ [] ys x x∈ys = x∈ys
clique∈ᵥclique++ʳ (x₁ ∷ xs) ys x x∈ys = ⇀ᵣ (clique∈ᵥclique++ʳ xs ys x x∈ys)

clique∈ᵥclique++ˡ : { A : Set } → ∀ ( xs ys : List A ) ( x : A ) → x ∈ᵥ (clique xs) → x ∈ᵥ (clique (xs ++ ys))
clique∈ᵥclique++ˡ (x₁ ∷ xs) ys .x₁ (⇀ₗ x∈Vx) = ⇀ₗ x∈Vx
clique∈ᵥclique++ˡ (x₁ ∷ xs) ys x (⇀ᵣ x∈xs) = ⇀ᵣ (clique∈ᵥclique++ˡ xs ys x x∈xs)

clique-++-connect : { A : Set } → ∀ ( xs ys : List A ) → clique (xs ++ ys) ≈ ((clique xs) ⇀ (clique ys))
clique-++-connect [] ys = ≈-trans ≈-refl (≈-comm (⇀-subst (≈-comm clique[]≈ε) ⇀-identʳ))  
clique-++-connect (x ∷ xs) ys = record
                                  { vₗ = λ { (⇀ₗ x₁) → ⇀ₗ (⇀ₗ x₁)
                                           ; (⇀ᵣ x₁) → _≈_.vₗ ⇀-assoc (⇀ᵣ (_≈_.vₗ (clique-++-connect xs ys) x₁))
                                           }
                                  ; vᵣ = λ { (⇀ₗ (⇀ₗ x₁)) → ⇀ₗ x₁
                                           ; (⇀ₗ (⇀ᵣ {x₂} x₁)) → clique∈ᵥclique++ˡ (x ∷ xs) ys x₂ (⇀ᵣ x₁)
                                           ; (⇀ᵣ {z} x₁) → clique∈ᵥclique++ʳ (x ∷ xs) ys z x₁
                                           }
                                  ; eₗ = λ { (⇀ᵣ x₁) → _≈_.eₗ ⇀-assoc (⇀ᵣ (_≈_.eₗ (clique-++-connect xs ys) x₁))
                                           ; (⇀ₗᵣ x∈Vx x₁) → _≈_.eₗ ⇀-assoc (⇀ₗᵣ x∈Vx (_≈_.vₗ (clique-++-connect xs ys) x₁))
                                           }
                                  ; eᵣ =  ?
                                  }
```

